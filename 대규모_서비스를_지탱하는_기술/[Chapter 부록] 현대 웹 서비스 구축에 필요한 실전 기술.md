# Chapter.부록 현대 웹 서비스 구축에 필요한 실전 기술

## 현대 웹 서비스 구축에 필요한 실전 기술 - 대규모 서비스에 대응하기 위해서

### **성장하는 서비스, 계속 증가하는 데이터**

---

웹 서비스 구축을 위한 **실전적인 기술**에 대해 알아보자.

```java
1.작업 큐 시스템
2.스토리지 선택 (RDBMS와 key - value 스토어)
3.캐시 시스템
4.계산 클러스터
```

## 작업 큐 (Job - Queue) 시스템 : TheSchwartz, Gearman

### 웹 서비스와 요청

---

- 웹 서비스에서는 기본적으로 요청이 **동기적**으로 실행된다. **즉, 요청에 기인하는 모든 처리가 끝난 다음에 응답이 반환된다.**
    - 계속 성장해가는 웹 서비스에서는 데이터가 서서히 축적되면서 데이터를 추가하고 갱신하는 처리가 점점 무거워 지게된다.
    - 양호했던 성능이 악화된다.
    - 서비스 사용자 경험에 영향을 주는 경우가 발생한다.
- 이런 경우에 **작업 큐 (Job - Queue)**을 사용함으로써 나중에 미뤄도 되는 처리를 **비동기**로 실행할 수 있고 **사용자 경험도 개선할 수 있다.**
    - ex) 하테나 북마크에서 사용자가 URL을 북마크 했다.
    - 이에 따라 URL 개요를 얻거나 / 키워드 추출 / 카테고리 판정 등 나중에 처리해도 되는 작업을 비동기로 실행
    - 만일 **동기적으로 처리**했다면 북마크할 때 마다 **수 초에서 수십 초 이상 대기해야되는 문제가 발생**

### 작업 시스템 입문

---

**소규모 애플리케이션의 경우**

- 웹 애플리케이션의 일부 처리를 가장 간단하게 비동기화 하는 방법은 **비동기화 하고자 하는 처리를 독립된 스크립트로 해당 스크립트를 애플리케이션 내부에서 호출하는 방법**
- 위의 방법으로 간단하게 처리할 수 있지만, 스크립트 시작과 초기화의 오버헤드가 커서 성능이 좋지 않다.
- 또한 일시적으로 대량의 비동기 처리를 실행시키려 하면 그 수만큼의 프로세스를 실행시키려 하기 때문에 성능상 단점이 된다.

**대규모 서비스의 경우**

- 어느 정도 양이 있는 비동기 처리를 안정적으로 수행하려면 **작업큐(Job - Queue) 와 워커 (Worker)를 세트로 한 작업큐 시스템을 사용**하는 것이 일반적이다.
- 작업큐에 실행하고자 하는 처리(작업)를 등록한다.
- 워커에서 작업을 추출해서 처리한다.
- 작업큐를 통해 일시적으로 대량의 처리가 등록되었을 때 부하의 변동을 흡수할 수 있다.
- 워커는 항상 실행해둠으로써 작업을 처리할 때 초기화 오버헤드를 거의 없앨 수 있다.

**작업 큐 시스템의 기본적인 처리 흐름**

![KakaoTalk_20230812_215145692.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230812_215145692.jpg)

- **클라이언트(웹 애플리케이션)**
    - 작업을 투입한다. 작업을 투입한 다음 처리를 계속 진행할 수 있다.
- **작업큐**
    - 작업을 쌓는다.
- **워커**
    - 작업큐를 참조하고 미실행된 작업을 추출해서 작업을 실행한다.

### 하테나에서의 작업큐 시스템

---

**TheSchwartz**

- MySQL과 같은 **RDBMS를 사용하는 작업큐 시스템**
- MySQL로 작업큐를 관리함으로써 매우 높은 **신뢰성과 안정성을 확보**
- 비동기 처리에서는 작업을 확실하게 처리하는 것이 중요하므로 높은 신뢰성은 큰 장점이 된다.
- 하지만 속도에서는 다소 희생이 따르므로 다루는 작업의 크기는 어느 정도 크게 하는 편이 좋다.

**Gearman**

- TheSchwartz보다 **가벼운 작업큐 시스템**
- 작업큐로 RDBMS가 아닌 **독자적인 데몬을 사용해서 작업의 정보를 메모리에 저장함으로써 성능을 확보**
- 신뢰성에 희생이 따르므로 확실한 처리가 필요한 용도로는 적합하지 않다.
- 작업을 투입할 때 다음의 세 가지 패턴을 취할 수 있다.
    - 동기적으로 순번대로 처리
    - 동기적으로 병렬로 처리
    - 비동기적으로 백그라운드로 처리
- TheSchwartz보다 유연한 처리 가능
- 비동기적으로 병렬처리 치킴으로써 전체 처리시간을 크게 단축시킬 수 있다.

**WorkerManager에 의한 관리**

- 워커 프로세스를 세세하게 제어하고자 하기위에 Apache의 prefork 모델을 참고하여 자체적으로 개발한 워커매니저
- **워커 프로세스의 라이프사이클 관리 , 프로세스 관리, 데몬화 수행**
- **웨커 프로세스의 프로세스 개수 관리, 병행처리가 가능한 작업수를 제어**
- **로그 출력, 작업을 처리한 타임스탬프 등을 기록**

### 로그분석

---

- TheSchwartz는 **작업 처리시간과 작업이 두입된 후 실제로 처리가 수행되기까지의 지연시간을 기록**
- 이를 측정하여 워커의 **처리능력이 충분한지 여부를 확인**할 수 있다.
- 지연시간이 길어졌을 때는 아무리 비동기 처리라 하더라도 사용자 경험이 문제가 되는 경우도 있다.
- 따라서 이런 경우는 워커의 튜닝과 보강을 생각해야할 시점이다.

## 스토리지 선택 : RDBMS와 Key - Value 스토어

### 증가하는 데이터를 어떻게 저장할까?

---

- 웹 애플리케이션에 있어서 **“증가하는 데이터를 어떻게 저장할까?”**는 영원한 과제 ⇒ 그만큼 중요
- 수십 GB , 수백 GB, TB를 넘는 데이터를 다루는 스토리지는 약간의 구성 변경이나 액세스 패턴 변화로 예상 밖으로 응답속도가 저하되는 경우가 있다.
- 따라서 **데이터량이나 스키마, 액세스 패턴에 맞는 스토리지를 선택하는것은 매우 중요하다.**

**웹 애플리케이션과 스토리지** 

- `스토리지` : 애플리케이션 데이터를 **영속적**으로 혹은 **일시적으로 저장**하기 위한 기능
- `원본 데이터` → 서비스의 근본적인 신뢰성과 관계되어 있으므로 **최상급 신뢰성을 확보**
- `캐시와 같은 데이터` → 신뢰성은 그 다지 중요시되지 않으니 **성능을 높이거나 비용을 줄일 필요가 있다.**
- 데이터 특성 뿐만 아니라 데이터의 크기나 갱신빈도, 성장속도와 같은 항목도 중요하다.

|  | 필요한 신뢰성 | 크기 | 갱신빈도 | 종류 |
| --- | --- | --- | --- | --- |
| 블로그 본문 | 고 | 소 | 저 | 원본 데이터 |
| 디지털카메라 사진 | 고 | 대 | 저 | 원본 데이터 |
| 검색용 인덱스 | 중 | 중 | 고 | 가공 데이터 |
| HTML 처리 후 본문 | 저 | 소 | 저 | 캐시 |

**적절한 스토리지 선택의 어려움**

- 저장하고자 하는 데이터의 특성에 맞는 스토리지를 선택하는 것이 비용과 성능, 안정성의 균형을 높은 차원으로 달성할 수 있다.
    - 서비스를 시작한 후에 규모가 커지게 되면 , 저장된 데이터량도 커지고 서비스의 정지의 영향도 커져 어려워진다.
    

### 스토리지 선택의 전제가 되는 조건

---

- 스토리지를 선택할 때에는 **애플리케이션에서의 액세스 패턴을 이해**하는 것이 중요하다.
- 액세스 패턴으로는 아래 여섯 가지 지표가 선택의 중요한 판단 포인트가 된다.

```java
1. 평균크기
2. 최대크기
3. 신규추가빈도
4. 갱신빈도
5. 삭제빈도
6. 참조빈도

etc
크기에 요구되는 신뢰성
허용할 수 있는 장애 레벨
사용할 수 있는 하드웨어나 쓸 수 있는 예산
```

### 스토리지 종류

---

```java
- RDBMS : MySQL, PostgreSQL 등
- 분산 key-value 스토어 : memCached, TokyoTyrant 등 (최신 ? Apache Cassandra, Amazon DynamoDB , Redis 등)
- 분산 파일시스템: MogilegFS , GlusterFS, Lustre
- 그 밖의 스토리지 : NFS 계열 분산 파일시스템, DRBD, HDFS
```

### RDBMS

---

- **Relation Database Manangement System : RDBMS 란 표 형식으로 데이터를 저장하고  SQL 언어로 데이터를 조작을 수행하는 시스템**
- 다양한 데이터를 저장하거나 강력한 질의를 할 수 있어 범용성이 높은 스토리지

**MySQL**

- SQL을 해석해서 실행하는 블록기능 / **실제로 데이터를 보관하는 기능 블록 = 스토리지 엔진**
- `스토리지 엔진` : DB에서 데이터를 어떠한 방식으로 저장하고 접근할 것인지에 대한 기능을 제공한다.
- 주요한 스토리지 엔진은 MyISAM과 InnoD, Maria가 있다.

![KakaoTalk_20230813_024321782.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230813_024321782.jpg)

**MyISAM**

- **MySQL 5.1의 표준 스토리 엔진**
- 1개의 테이블이 실제 파일 시스템 상에 3개의 파일(정의,인덱스,데이터)로 표현된다.
- 과거의 update나 deltet를 한 적이 없는 테이블에 대해 insert 조작(추가처리)을 빠르게 할 수 있다.
- 시작 , 정지도 빠르며 , 테이블 이동이나 이름 변경을 파일시스템 조작으로 직접 할 수 있는 등 DB운용은 용이하다.
- 반면, DB 프로세스가 **비정상 종료하면 데이블이 파손될 가능성이 높다**
- **트랜잭션 기능이 없다.**
- update, delete, insert(추가처리 이외)가 **테이블 락(Table Lock)**으로 되어 있어서 갱신이 많은 용도는 성능이 불리하다.

**InnoDB**

- **MyISAM과는 대조적인 스토리 엔진**
- 스토리지 엔진 전체에서 사전에 정의한 소수의 파일에 데이터를 저장한다.
- **트랜잭션을 지원한다.**
- **비정상 종료 시 복구기능이 있다.**
- **데이터 갱신이 로우 락(Row Lock) 으로 되어 있다.**
- 반면 데이터량에 따라서는 시작, 정지가 수 분 정도 걸린다거나 테이블 조작을 모두 DB를 경유해서 수행해야 하는 등의 단점이 있다.

**Maria**

- MyISAM의 후속으로 개발되고 있는 스토리 엔진
- MyISAM에 비해 트랜잭션 기능과 비정상 종료시 복구기능을 추가한 것으로 약점이 크게 보완됨

**MyISAM vs InnoDB**

| 액세스 패턴 | 적합한 스토리 엔진 |
| --- | --- |
| 추가처리만 한다. | MyISAM |
| 갱신빈도가 높다. | InnoDB |
| 트랜잭션이 필요하다. | InnoDB |
| SELECT COUNT(*)를 사용 | MyISAM |
- **애플리케이션 기능이나 특성을 고려해서 보다 적절한 스토리지 엔진을 선택하자.**

### 분산 Key-value 스토어

---

- `key-value 스토어`: key와 value 쌍을 저장하기 위한 심플한 스토리지
- `분산 key - value 스토어` :  key - value 스토어에 네트워크를 지원함으로써 다수의 서버로 확장시키는 기능을 지님
- `key-value 스토어` 는 RDBMS에 비해 기능적으로는 부족하지만 , 성능이 10~100배 이상이다.

**memcached**

- 파일 시스템을 사용하지 않고 메모리 상에서 동작하므로 매우 빠르며, 재시작 할 때 메모리가 모두 사라져버린다.
- 따라서 원본 데이터 저장으로는 부적합, 재생성 시에 시간이 걸리는 가공 데이터 저장에도 부적합
- 캐시 데이터의 경우 가장 잘 활용할 수 있는 데이터이다.
- memcached를 참조해서 찾기 못한경우에만 RDBMS 참조
- 외부 리소스에 질의한 결과를 캐싱하는 등 다양한 캐시용 스토리지로 활용
- 캐시로 한정할 경우에서는 서버에는 메모리만 충분히 탑재해두면 된다. 따라서 저가 하드웨어를 나열해서 대량의 캐시풀을 구축하고 고가 하드웨어를 요구하는 RDMBS 대수를 줄이는 구성이 가능

**TokyoTyrant**

- 로컬에서 동작하는 key - value 스토어인 ToykoCabinet에 네트워크를 지원하도록 한 구현.
- ToykoCabinet은 디스크에 데이터를 기록함으로써 데이터를 영속화할 수 있고 TokyoTyrant도 그 특징을 이어받고 있다.
- 다중성을 높이기 위한 레플리케이션 기능을 내장
- 다양한 형식으로 데이터를 다루기 위한 API 마련

### 분산 파일 시스템

---

- `분산 파일 시스템(Distributed File System):`여러 컴퓨터 노드로 구성된 네트워크 환경에서 파일을 저장, 관리 및 공유하기 위한 시스템입니다
- 어느 정도 이상인 크기의 데이터를 저장하는 데 적합

**MogileFS**

- 작은 대량의 파일을 다룰 목적으로 Perl로 구현된 분산 파일시스템
- **대량의 수KB ~ 수십MB 정도의 이미지 파일을 효율적으로 저장하기 위한 시스템**
- **갱신되지 않고 참조하기만 하는 용도에 적합**, 즉 업로드 이미지 파일을 접수받는 웹 애플리케이션에 적합
- 스토리지 서버 상에서 개개의 파일은 실제 파일시스템 상에서도 하나의 파일로 저장
    - 통상 하나의 파일은 3중으로 다중화되어 일부 스토리지 서버가 고장나서 데이터가 손실되더라도 시스템 전체로서는 계속 정상적으로 동작할 수 있도록 설계 되어있음
- 파일 저장소와 파일을 특정 짓기 위한 키와 대응관계는 메타데이터로 RDBMS에 저장
- 파일을 참조할 때는 통상의 파일시스템처럼 마운트하는 것이 아니라 WebDAV 프로토콜로 얻게 된다.
- 따라서 MogilesFS를 사용할 경우에는 애플리케이션 측에 구현이 필요하다.

### 그 밖의 스토리지

---

**NFS 계열 분산 파일 시스템**

- 특정 서버의 파일시스템을 다른 서버에서 마운트해서 해당 서버의 로컬 파일시스템과 마찬가지로 조작할 수 있도록 하는 기술
- 대부분의 UNIX 시스템에 구현되어 있으며, 간단하게 사용할 수 있다는 점이 특징
- 반면, 커널 레벨에서 구현되어 있는 경우가 많아 서버 측에 장애가 발생하면 클아이언트의 동작도 정지해버리는 경우가 발생한다.
- NFS의 개선버전 ⇒ GlusterFS / Lustre

**WebDAV 서버**

- HTTP를 기반으로 한 프로토콜로 , 애플리케이션 계층에서 구현되는 경우가 많아 보다 안정된 시스템을 구축할 수 있다.
- 프로세스 간 데이터를 건네주는 것처럼 일시적으로 필요한 데이터를 저장하는 장소로 적합하다.

**DRBD**

- Distributed Replicated Block Device 는 네트워크 계층에서 RAID라고 할 수 있는 기술
- 블록 디바이스 레벨에서 분산, 다중화 할 수 있는 기술로 , 2대의 스토리지 서버의 블록 디바이스 간 동기를 실현한다.

**HDFS**

- `HDFS(Hadoop Distributed File System`) : 하둡용으로 설계된 분산 파일시스템이다.
- 파일을 64MB씩 분할해서 저장하고 , 수백 MB ~ 수십GB의 거대한 데이터를 저장하는 것을 목적으로 한다.
- 기본적인 액세스는 Java ApI 경유로 되어 있고 , MapReduce를 대상으로 한다는 특성에서 개개의 조작에 대한 응답이 빠르지 않으므로 실시간성을 필요로 하는 용도에는 적합하지 않다.
- 거대한 파일을 저장하고 있으면서 한 번에 처리하려는 용도에 적합

### 스토리지의 선택전략

---

- 스토리지도 다양한 종류가 있어서 애플리케이션의 특성에 맞는 적절한 것을 선택하기란 상당히 어렵다.
- 선택한 다음은 해당 스토리지를 **적절한 하드웨어 상에 구축하고 적절하게 설정, 튜닝할** 필요가 있다.
- 또한 **저장되는 데이터량 증가나 액세스 패턴 변화에 따라 설정을 변경하거나 하드웨어를 보강하고, 다른 방식의 스토리지로 옮길 필요**가 생길 수 있다.
- **잘 동작하는 것에 만족하지 않고 항상 성능을 감시함으로써 안정되고 확장하는 스토리지를 구성하자.**

![KakaoTalk_20230813_213316565.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230813_213316565.jpg)

## 캐시 시스템 : Squid, Varnish

![KakaoTalk_20230813_014823233.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230813_014823233.jpg)

- 웹 애플리케이션의 부하가 서서히 증가해서 시스템 용량이 부족해졌을 때에 HTTP 레벨의 캐싱을 수행하는 **HTTP 가속기를 사용함으로써 낮은 비용으로 효과가 높은 대책을 세울 수 있다.**
- `포워드 프록시 ( Forward Proxy)`  : 클라이언트가 외부 서버에 액세스할때 사이에 두는 프록시
- `리버스 프록시`  : 역으로 외부의 클라이언트가 내부 서버에 액세스할 때 사이에 두는 프록시
- **프록시는 요청에 대한 응답을 캐싱해둠으로써 대역이나 서버 리소스를 소비하지 않고 빠르게 요청을 처리할 수 있다.**

### Squid - 기본적인 구성

---

- 리버스 프록시 캐시 서버의 구현으로 가장 유명한 캐시 서버이다.
- HTTP, HTTPS ,FTP용 다기능 프록시이다.
- 액세스 컨트롤이나 인증기능도 갖추고 있다.

![KakaoTalk_20230813_015544685.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230813_015544685.jpg)

(리버스 프록시와 AP 서버 , 2대로 이루어진 구성을 전제로 설명)

- 리버스 프록시에서 AP 서버로 전송되고 있던 요청 중 일부를 캐시 서버에서 처리할 수 있게 되어 시스템 전체 성능을 향상시킬 수 있다.
- `평상시` : 일정 비율의 요청을 캐시 서버에서 반환하여 AP 서버로의 요청을 반감시킬 수 있는 장점이있다. 소비되는 리소스를 절약
- `액세스 집중시` : 방대한 요청으로 인해 시스템 전체의 수용능력을 넘어서는 것을 막는 효과를 기대할 수 있다.
    - 이를 위해서 액세스가 집중된 콘텐츠를 캐시 서버에서 캐싱한다.

**여러 대의 서버로 분산하라**

- Squid 서버를 여러 대 나열함으로써 다중성을 띄게 할 수 있다.
    - ex) 2대를 구성한다면 1대는 스탠바이 역할 or 독립된 캐시 서버로서 동작 등 설정가능
- Squid를 연계시키는 것은  ICP(Inter-Cache-Protocol) 를 사용한다.
    - `ICP(Inter-Cache-Protocol)` : Internet -Draft로 정의되어 있는 프로토콜의 일종으로 , 캐시를 제어하기 위한 프로토콜
    - ICP를 사용하면 한쪽 캐시 서버가 수신한 요청에 대한 응답이 캐싱되지 않은 경우, 반대편 캐시 서버가 콘텐츠를 보유하고 있지 않은지를 질의할 수 있다.
    - 두 캐시 서버 모두 보유하고 있지 않은 경우에만 부모 서버인 AP서버로 질의하게 된다.

**2단 구성 캐시 서버 - CARP로 확장**

- 이미지 파일 등 크기가 큰 파일을 캐싱하게 되면 캐시 서버의 부하가 높아져 용량이 부족해질 경우가 발생한다. ⇒ **캐시 서버를 2단으로 구성함으로써 보다 확장성이 높은 캐시 서버군을 구성할 수 있다.**

![KakaoTalk_20230813_020523574.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230813_020523574.jpg)

1. 상단 Squid 프록시는 요청을 받아서 자신은 캐시를 보유하지 않고 하단 Squid 캐시 서버로 요청을 전송한다.
2. CARP (Cache Array Routing Protocol) 라고 하는 프로토콜에 따라 URL을 키로 적절한 Squid 캐시로 전송한다.
3. URL을 Key로 해서 하단 캐시 서버를 선택함으로써 특정 URL에 대해 특정 캐시 서버만 사용한다.

- 캐시 서버 대수가 늘어난 경우에도 효율적으로 캐싱할 수 있다.
- 캐시 대상 URL 수가 증가하더라도 하단 캐시 서버 대수만 늘려주면 확장가능하다.
- Squid에 의한 CARP 구현에서는 하단이 되는 캐시 서버의 사활감시도 수행해서 일부가 반응하지 않게 된 경우에도 작동하는 다른 서버로 처리를 할당하게 되어 , 일시적으로 캐시 히트율은 낮아지더라도 전체로서는 정상적으로 동작할 수 있게된다.

**COSS 크기 결정방법**

- 히트율을 높이기 위해서는 충분한 캐시 용량을 준비해둘 필요가 있다.
    - 캐시 용량은 클수록 좋은 것은 X , 과부족이 없는 상태가 최적
    - 너무 크면 초기 시작에 COSS 파일 생성 시간이 오래걸린다.
    - 디스크 용량을 압박한다.
    - 서버 재시작 등으로 메모리가 초기화 된 후에 디스크 상의 파일이 메모리에 올라가고 Squid 성능이 안정되기까지 시간이 걸린다.
    - 반대로 너무 작으면 캐시 히트율이 떨어진다.
- 최적의 용량은 `1초당 저장된 오브젝트수 X 오브젝트의 평균크기 X 오브젝트의 평균 유효시간(초)` 로 계산되는 크기이다.

**투입 시 주의점**

- Squid의 효율을 올릴 수록 장애가 발생했을 때의 영향이 커진다.
    - ex) 2대로 분산하고 있는데 1대가 고장나 남은 한대로는 부하를 감당할 수 없는경우
    - ex) 수리된 서버나 새로운 서버를 로드밸런서에 추가할 때 무심하게 추가하면 성능이 단번에 떨어져버리는 경우가 발생
        - 이는 재시작되거나 새로 구성한 Squid 서버가 요청을 처리하기 위한 충분한 준비가 되어있지 않기 때문(메모리에 올라와있지 않을때)
- 이와 같은 사태를 피하기 위해 사전에 평상시에 접수되는 요청을 보내서 워밍업을 해둘 필요가 있다.

### Varnish

---

- 고성능 HTTP 가속기, 리버스 프록시로서 캐시 서버에 특화되어있다.
- 유연한 설정언어를 갖고 있으며 모던한 설계를 채택하고 있다.
- 기본적으로 메모리 상에서 동작함으로써 Squid보다 빠르게 동작한다는 점이 특징이다.
- 고속화를 극한까지 추구한 설계로 이루어져 있다.

![KakaoTalk_20230813_022909839.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/KakaoTalk_20230813_022909839.jpg)

- 오브젝트(디폴트로는) mmap에 의해 디스크 상의 파일에 저장된다. 또한 프로세스를 재시작하면 캐시는 모두 사라진다.
    - mmap은 파일이나 디바이스를 메모리에 매핑하는 시스템콜이다.
    - Varnish를 최소 3대 이상 운용해서 1대를 재시작해도 캐시 히트율에 그다지 크게 영향을 주지 않도록 하는 것이 유효하다.
- 기본적인 설정은 명령줄 옵션으로 주고 프록시로서의 규칙은 설정파일(VCL :Varnish Configuration Language)에 기록한다.
- 그 자체로는 로그를 파일에 기록하는 기능이 갖춰져 있지 않고 공유 메모리 상에 기록한다.

## 계산 클러스터 : Hadoop

### 대량 로그 데이터의 병렬처리

---

- 대규모 웹 서비스를 운영하다 보면 로그 데이터가 대량으로 쌓인다.
- 대량의 로그 데이터의 처리를 한 번에 읽어들이는 것만으로도 어려우며, 통계처리나 분석할 경우 엄청나게 큰 계산 리소스를 필요로 한다.
- ex) 하테나 다이어리의 액세스 로그 하루 4GB / 로그 1개월분 120GB / 월간 고유 사용자를 계산하려하면 한 번에 처리해야되는데 평균 읽어들이는 속도가 50Mbps 라하면 5시간 걸린다.
- 따라서 빠르게 수행하기 위해서는 **병렬처리가 가능한 계산 클러스터가 필요**

### MapReduce의 계산모델

---

- Google이 2004년에 발표한 계산 모델
- 거대한 데이터를 빠르게 병렬로 처리하는 것을 목적으로 하며, 이 계산 시스템은 **다수의 계산 노드로 구성된 클러스터**와 **대량 데이터를 분산해서 저장하기 위한 분산 파일시스템으로 구성**된다.

![하둡.jpg](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/%25ED%2595%2598%25EB%2591%25A1.jpg)

![Untitled](Chapter%20%E1%84%87%E1%85%AE%E1%84%85%E1%85%A9%E1%86%A8%20%E1%84%92%E1%85%A7%E1%86%AB%E1%84%83%E1%85%A2%20%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%89%E1%85%A5%E1%84%87%E1%85%B5%E1%84%89%E1%85%B3%20%E1%84%80%E1%85%AE%E1%84%8E%E1%85%AE%E1%86%A8%E1%84%8B%E1%85%A6%20%E1%84%91%E1%85%B5%E1%86%AF%E1%84%8B%E1%85%AD%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%B5%20c5de9e9ad82844e09720674082bc1cf6/Untitled.png)

- MapReduce 계산 모델은 key와 value의 쌍의 리스트를 입력 데이터로 해서 최종적으로 value의 리스트를 출력한다.
- 계산은 기본적으로 Map단계와 Reduce 단계로 구성된다

**Map 단계**

- `Map 단계` : 마스터 노드에서 입력 데이터를 잘게 분할해서 각 노드로 분산
- 각 노드에서는 분할된 입력 데이터를 계산한다.
- 계산 결과를 key와 value쌍으로 구성된 중간 데이터로 출력한다.
- Map 단계의 처리는 다음과 같이 나타낼 수 있다.
    - (k1,v1) → list(k2,v2)

**Reduce 단계**

- `Reduce 단계` : Map 단계에서의 출력 데이터를 key(k2)별로 정리해서 key(k2)와 key에 대응하는 값의 리스트(list(v2))로 재구성한다.
- 각각의 key를 각 노드로 분산한다. → shuffle phase
- 각 노드에 있는 key(k2)와 key에 대응하는 값의 리스트(list(v2))를 입력 데이터로 해서 각 리스트 (list(v3))를 최종적인 출력 데이터로 하는 처리를 수행한다.
    - Reduce(k2,list(v2)) → (k2,list(v3)
- 최종적으로 각 노드에서 값의 리스트(list(v3))를 집약하면 계산이 완료된다.

**결론**

- **Map과 Reduce라는 두 가지 처리를 수행하는 함수를 준비하는 것만으로 대량의 데이터를 빠르게 처리할 수 있게 된다.**
- 대량의 입력 데이터를 읽어들이는 부분이 성능의 병목이 되는 경우가 있다. 따라서 MapReduce는 분산 파일시스템과 병용하는 것이 중요하다.
- 분산 파일시스템에서는 수GB 파일을 수십 MB크기로 분할하고 , 다수의 노드에 사전에 데이터를 분산 배치해둔다.
- 그리고 실제로 처리를 실행할 때 가능한 한 데이터가 로컬에 존재하는 노드에서 처리를 실행하도록한다.
- 고속으로 데이터를 읽어들여서 DVD 1장 분량의 데이터에 대한 grep을 2초만에 끝낼 수 있다.

### Hadoop

---

- Apache 프로젝트 중 하나로 MapReduce의 오픈소스 구현 중 하나다.
- MapReduce와 쌍을 이루는 분산 파일시스템은 Google에서는 GFS(google file system)로 구현되어 있고 , Hadoop에서는 오픈소스인 HDFS로 구현되어 있다.
- Hadoop은 Java로 구현되어 있다.

## 참고

**테이블 락 (Table Lock):**
테이블 락은 데이터베이스에서 전체 테이블에 대한 잠금을 의미합니다. 하나의 트랜잭션이 특정 테이블을 잠근 경우, 다른 트랜잭션은 그 테이블에 접근할 수 없게 됩니다. 이는 동시성을 제한하고 트랜잭션 간의 충돌을 방지하는 데 사용될 수 있습니다. 하지만 테이블 락은 다른 트랜잭션이 다른 테이블에 대한 작업도 막는다는 단점이 있어서 성능 저하의 원인이 될 수 있습니다.

**로우 락 (Row Lock):**
로우 락은 데이터베이스에서 개별 로우(행)에 대한 잠금을 의미합니다. 하나의 트랜잭션이 특정 로우를 잠근 경우, 다른 트랜잭션들은 그 로우에 대한 작업은 가능하지만, 잠긴 로우에 대한 작업은 차단됩니다. 이를 통해 동시성을 높일 수 있습니다. 로우 락은 특정 로우에 대한 작업만을 제한하기 때문에 효율적인 동시성 제어가 가능합니다.

일반적으로 로우 락은 테이블 락보다 세밀한 수준의 동시성 제어를 제공하며, 데이터베이스 시스템에서 효율적인 동시성과 성능을 유지하는 데 도움이 됩니다. 그러나 로우 락을 사용할 때에도 과도하게 많은 로우를 잠그게 되면 데드락(deadlock)이 발생할 수 있는 등 주의가 필요합니다.

---

 

**마운트(Mount)**는

 컴퓨터 시스템에서 특정 디렉토리나 파일 시스템을 다른 디렉토리에 연결하여 접근 가능하게 하는 프로세스나 기술을 가리킵니다. 특히 네트워크나 다른 물리적인 장치로부터 데이터를 가져와 로컬 파일 시스템처럼 사용할 수 있도록 하는 것을 의미합니다.

예를 들어, 네트워크 상의 다른 서버에 위치한 파일 시스템을 현재 서버의 디렉토리에 마운트하면, 마치 해당 파일 시스템이 로컬 파일 시스템인 것처럼 접근할 수 있게 됩니다. 이를 통해 원격 서버의 파일이나 디렉토리를 로컬 시스템에서 간편하게 사용하거나 조작할 수 있습니다.

## 출처

[맵/리듀스 (Map/Reduce) 이해하기](https://cskstory.tistory.com/49)